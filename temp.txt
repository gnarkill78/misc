I have a docker app with js webserver frontend using jade to serve the main page, and a flask API.
This is a snippet of the submit form from index.jade:

    form(method="post", action="/users/status")
      label(for='status') Update Status: &nbsp;
      input(type='text',name='status',id='status')
      input(type='submit',name='submit',value='Submit').submit-button

This is the /status API endpoint snippet

@app.route('/status') # get status for a user
def status():
    username = request.args.get('username')
    if not username:
        return {"status": "ERROR"}
    cur = db.cursor()
    cur.execute("SELECT status from blog WHERE username = '" + username + "'")
    row = cur.fetchone()
    return jsonify({"status":row[0]})

I also have a users.js sitting in the frontend.
What do I need to do to actually utilise the form properly to actually write a status update into the blog db?





router.post('/post', function(req, res, next) {
  const { username, status, postContent } = req.body; // Assuming your form sends username, status, and post content

  // Construct the URL for the backend API endpoint to add a new post
  const url = `http://api:8080/post`;

  // Make a POST request to the backend API endpoint
  const apiRequest = http.request(url, {
    method: 'POST',
    headers: {"Content-Type": 'application/x-www-form-urlencoded; charset=UTF-8'}
  }, (response) => {
    response.on("data", (data) => {
      console.log(`Response from adding post: ${data.toString()}`);
      // Optionally, you can handle the response here
      // For example, redirect to a different page or send a response to the client
      res.redirect('/');
    });
  });

  // Send the post data as data in the request body
  apiRequest.write(`username=${username}&status=${status}&postContent=${postContent}`);
  apiRequest.end();
});


To ensure that you don't expose sensitive information like request paths in parameters, you need to implement proper security measures both on the backend (Flask API) and the frontend (Express.js in your case). Here are some steps you can take:

Backend (Flask API):
Sanitize Inputs: Always validate and sanitize inputs to your Flask API endpoints to prevent injection attacks.
Limit Logging: Ensure that you don't log sensitive information such as request paths unless absolutely necessary. If you must log them, make sure to use appropriate log levels and consider masking or obfuscating sensitive parts.
Secure Routes: Use proper authentication and authorization mechanisms to secure your routes. Don't expose sensitive data or functionality without proper authentication.
HTTPS: Enforce HTTPS to encrypt data transmitted between the client and the server, including request paths.
Frontend (Express.js):
Avoid Query Parameters: In your Express.js frontend, avoid passing sensitive information like request paths as query parameters in URLs.
Client-Side Security: Implement client-side security measures such as input validation and sanitization to prevent injection attacks.
HTTPS: Ensure that your frontend communicates with the backend over HTTPS to prevent eavesdropping and data tampering.
Docker Configuration:
Network Isolation: Ensure that your Docker containers are properly configured with network isolation to prevent unauthorized access to sensitive information.
Security Audits and Penetration Testing:
Regularly conduct security audits and penetration testing to identify and fix any vulnerabilities in your application stack.
Security Best Practices:
Follow security best practices for both Flask and Express.js development.
Stay updated with security advisories and patches for the libraries and frameworks you use.
In conclusion, while Express.js can play a role in securing your frontend, ensuring that sensitive information like request paths isn't exposed requires a holistic approach involving both backend and frontend development practices, as well as proper configuration of your Docker environment.
